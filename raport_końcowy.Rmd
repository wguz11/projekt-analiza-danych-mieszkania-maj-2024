---
title: 'Analiza mieszkań na sprzedaż w Polsce'
subtitle: 'Analiza opisowa'
author: "Kinga Kreft, Wiktoria Guz, Edyta Drząszcz"
date: "`r Sys.Date()`"
output:
  rmdformats::downcute:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    highlight: pygments
---


```{r setup, include=FALSE}
## Global options
knitr::opts_chunk$set(cache = TRUE)
library(naniar)
library(ggplot2)
library(hrbrthemes)
library(plotly)
library(moments)
library(ISLR)
library(finalfit)
library(GGally)
library(tidyverse)
library(dlookr)
library(editrules)
library(VIM)
library(validate)
library(dplyr)
library(scales)
#library(summarytools)
#library(psych)
mieszkania <- read.csv("apartments_pl_2024_05.csv")
```
Dane zostały wczytane z pliku CSV, który zawiera informacje o mieszkaniach dostępnych na sprzedaż w Polsce w maju 2024 roku.  

# 1. Data wrangling
Data wrangling, znane również jako data munging, to proces przygotowywania danych do analizy poprzez oczyszczanie, transformowanie i strukturalizowanie surowych danych. Celem jest przekształcenie danych w formę, która jest łatwiejsza do analizy, eliminując błędy, usuwając duplikaty, uzupełniając brakujące wartości i konwertując dane do odpowiednich formatów.

## 1.1 Wizualizacja brakujących danych

Na początku identyfikujemy brakujące dane w zestawie, aby upewnić się, że analiza będzie oparta na kompletnych i spójnych danych.
Używamy funkcji vis_miss() do wizualizacji braków oraz missing_pattern() do zrozumienia wzorców brakujących wartości.


```{r}
vis_miss(mieszkania)
```
Łącznie brakujących danych w całym zbiorze jest 6,3%. Zmienną, dla której wystąpił największy brak danych (aż 73%) była zmienna "condition", która jest zmienną binarną, określającą kondycję lokalu. Drugą zmienną z największymi brakami (41%) była zmienna określająca rodzaj materiału, z jakiego jest zbudowany budynek, w którym znajduje się mieszkanie. Kolejne zmienne, które miały znaczące braki dane to: rodzaj mieszkania (20%), piętro, na którym się znajduje (17%) i rok wybudowania (16%).


```{r}
missing_pattern(mieszkania, rotate.names = TRUE)
```

## 1.2 Reguły walidacji danych
Tworzymy zestaw reguł, które definiują poprawność danych. Reguły te pozwalają wyłapać wartości błędne, np. ujemne ceny lub powierzchnie mieszkań.
Dzięki temu możemy upewnić się, że dane spełniają podstawowe założenia logiczne.

```{r}
reguly <- editset(c(
  "price>0",
  "squareMeters>0",
  "rooms>0",
  "floor>0",
  "floorCount>0"
  ))
```
Kolejno sprawdzamy naruszenie reguł.
Wyniki pokazują, ile rekordów łamie zdefiniowane reguły, co może wskazywać na błędy w danych.
summary(violatedEdits(reguly, mieszkania))

```{r}
summary(violatedEdits(reguly, mieszkania))
bledy <- violatedEdits(reguly, mieszkania)
plot(bledy) # Wizualizacja błędów dla łatwiejszej interpretacji
```
Następnie przeprowadzona została zamiana pustych ciągów lub niepoprawnych wartości na NA
Dane mogły zawierać puste ciągi (" ", "") lub nieprawidłowe wartości, które zostały zamienione na NA, aby łatwiej było je wykluczyć.


```{r}
mieszkania[mieszkania == " "] <- NA

mieszkania[mieszkania == "  "] <- NA

mieszkania[mieszkania == ""] <- NA

mieszkania[localizeErrors(reguly,mieszkania)$adapt] <- NA
```


## 1.3 Imputacja brakujących danych

Uzupełnianie brakujących danych metodą hot-deck, która zastępuje brakujące wartości na podstawie podobnych rekordów.
Jest to efektywna metoda w przypadku, gdy dane mają wiele braków, ale są wystarczająco kompletne do uzupełnienia na podstawie istniejących wzorców.

```{r}
czyste_mieszkania <- hotdeck(mieszkania)

```
Po uzupełnieniu braków sprawdzamy podsumowanie danych, aby upewnić się, że proces przebiegł pomyślnie.

```{r}
summary(czyste_mieszkania)

```
## 1.5 Transformacja danych
Aby dostarczyć dodatkowych informacji wartych przeanalizowania, tworzymy nowe zmienne.
Pomagają one w lepszym zrozumieniu danych i umożliwiają bardziej szczegółowe analizy.
W tym celu tworzymy zmienną "pricePerSquareMeter" określającą cenę za metr kwadratowy. Jest to ważna metryka w analizie rynku nieruchomości, ponieważ pozwala na porównanie cen mieszkań niezależnie od ich wielkości.

```{r}

czyste_mieszkania <- czyste_mieszkania %>% mutate(pricePerSquareMeter = price / squareMeters)
```

View(czyste_mieszkania)
Dodatkowo, warto jet utworzyć kategorię wielkości mieszkań.
W tym celu zastosujemy podział mieszkań na małe, średnie i duże na podstawie powierzchni użytkowej. Kategoryzacja ta ułatwi analizę porównawczą.
```{r}
czyste_mieszkania <- czyste_mieszkania %>% mutate(
  sizeCategory = case_when(
    squareMeters < 40 ~ "Małe", # Mieszkania poniżej 40m2
    squareMeters >= 40 & squareMeters < 80 ~ "Średnie", # Mieszkania od 40m2 do 80m2
    squareMeters >= 80 ~ "Duże" # Mieszkania powyżej 80m2
  )
)
```
Dodatkowo, w celu ułatwienia przetwarzania danych, usuwamy kolumny z wartościami logicznymi. Zmiennych z tymi danymi i tak nie będziemy analizować w dalszej części projektu, więc usuwamy je w celem uzyskania większej przejrzystości oraz zminimalizowania wielkości danych.

```{r}

czyste_mieszkania <- czyste_mieszkania[, !sapply(czyste_mieszkania, is.logical)]

```

# 2.Wizualizacja danych
Wizualizujemy ceny mieszkań na sprzedaż w Polsce w zależności od stanu mieszkania, całościowo oraz za metr kwadratowy

```{r}
options(scipen=999)
ggplot(czyste_mieszkania, aes(x=price,fill=condition)) + geom_histogram(binwidth=100000) + labs(title="ceny mieszkań na sprzedaż w zależności od stanu mieszkania", x="cena", y="Liczba mieszkań") + theme_ipsum(base_family="sans") +  scale_x_continuous(labels  = 
                       label_number(scale = 1e-6, prefix = "", suffix = " MLN ZŁ", accuracy = 1)) 
ggplot(czyste_mieszkania, aes(x=pricePerSquareMeter,fill=condition)) + geom_histogram(binwidth=1000) + labs(title="ceny mieszkań za metr kwadratowy w zależności od stanu mieszkania", x="cena za metr kwadratowy", y="ilość") + theme_ipsum(base_family="sans") + scale_x_continuous(labels  = 
                       label_number(scale = 1e-3, prefix = "", suffix = " TYS ZŁ", accuracy = 1))

```


Wizualizujemy ceny mieszkań na sprzedaż w Polsce w zależności od tego czy jest parking, całościowo oraz za metr kwadratowy

```{r}

ggplot(czyste_mieszkania, aes(x=price,fill=hasParkingSpace)) + geom_histogram(binwidth=100000) + labs(title="ceny mieszkań w zależności od występowania parkingu", x="Cena", y="Liczba mieszkań") + theme_ipsum(base_family="sans") +  scale_x_continuous(labels  = 
                       label_number(scale = 1e-6, prefix = "", suffix = " MLN ZŁ", accuracy = 1)) 

ggplot(czyste_mieszkania, aes(x=pricePerSquareMeter,fill=hasParkingSpace)) + geom_histogram(binwidth=1000) + labs(title="ceny mieszkań za metr kwadratowy w zależności od występowania parkingu", x="Cena za metr kwadratowy", y="Liczba mieszkań") + theme_ipsum(base_family="sans") +  scale_x_continuous(labels  = 
                       label_number(scale = 1e-3, prefix = "", suffix = " TYS ZŁ", accuracy = 1)) 

```

Wizualizujemy ceny mieszkań na sprzedaż w Polsce w zależności od rodzaju zabudowania, całościowo oraz za metr kwadratowy

```{r}
ggplot(czyste_mieszkania, aes(x=price,fill=type)) + geom_histogram(binwidth=100000) + labs(title="ceny mieszkań na sprzedaż w zależności od rodzaju zabudowy ", x="cena", y="Liczba mieszkań") + theme_ipsum(base_family="sans")
ggplot(czyste_mieszkania, aes(x=pricePerSquareMeter,fill=type)) + geom_histogram(binwidth=500) + labs(title="ceny mieszkań na sprzedaż za metr kwadratowy w zależności od rodzaju zabudowy", x="cena za metr kwadratowy", y="Liczba mieszkań") + theme_ipsum(base_family="sans")

```

Wizualizujemy ceny mieszkań na sprzedaż w Polsce w zależności od rodzaju materiałów budowalnych, całościowo oraz za metr kwadratowy
```{r}
ggplot(czyste_mieszkania, aes(x=price,fill=buildingMaterial)) + geom_histogram(binwidth=100000) + labs(title="ceny mieszkań na sprzedaż w zależności od materiałów budowlanych", x="cena", y="Liczba mieszkań") + theme_ipsum(base_family="sans")
ggplot(czyste_mieszkania, aes(x=pricePerSquareMeter,fill=buildingMaterial)) + geom_histogram(binwidth=500) + labs(title="ceny mieszkań na sprzedaż za metr kwadratowy w zależności od materiałów budowlanych", x="cena", y="Liczba mieszkań") + theme_ipsum(base_family="sans")

```

Wizualizujemy rozkład cen mieszkań na sprzedaż w Polsce w zależności od wielkości mieszkania, całościowo oraz za metr kwadratowy

```{r}
ggplot(czyste_mieszkania, aes(x = price, fill = type)) +
geom_density(alpha = 0.5) +
labs(
title = "Rozkład cen mieszkań według standardu lokalu",
x = "Cena" ,
y = "Liczba",
fill = "Typ"
) +
theme_minimal()

ggplot(czyste_mieszkania, aes(x = pricePerSquareMeter, fill = sizeCategory)) +
  geom_density(alpha = 0.5) +
  labs(
    title = "Rozkład cen mieszkań za metr kwadratowy według wielkości lokalu",
    x = "Cena za metr kwadratowy" ,
    y = "Liczba",
    fill = "Wielkość"
  ) +
  theme_minimal()
```
Wizualizujemy rozkład cen mieszkań na sprzedaż w Polsce w zależności od miasta, całościowo oraz za metr kwadratowy


```{r}
miasta <- czyste_mieszkania %>%
  mutate(city_change = case_when(city == "lodz"~ "Łódź",
                                 city == "bialystok" ~ "Białystok"))

ggplot(miasta, aes(x = city_change, y = price)) +
geom_boxplot(fill = "pink", color = "blue") +
labs(
title = "Cena mieszkań według miasta",
x = "miasto" ,
y = "cena"
) +
theme_minimal()+
theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(czyste_mieszkania, aes(x = city, y = pricePerSquareMeter)) +
  geom_boxplot(fill = "pink", color = "blue") +
  labs(
    title = "Cena mieszkań według miasta",
    x = "miasto" ,
    y = "cena za metr kwadratowy"
  ) +
  theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r}
ggcorr(
data = czyste_mieszkania %>% select(where(is.numeric)),
method = c("pairwise.complete.obs" , "pearson"),
label = TRUE
) +
theme(
axis.text.x = element_text(hjust = 1), 
axis.text.y = element_text(hjust = 1)
)
```
Powyżej przedstawiona jest macierz korelacji. Najsilniej skorelowane są ze sobą odległości od poszczególnych miejsc (np. szkoła z restauracją, czy apteką). Może być to spowodowane tym, że zwykle tego typu placówki są w centrum i znajdują się blisko siebie. Silnie skorelowane są ze sobą również ilość pokoi i ilość metrów kwadratowych. Oznacza to, że wraz ze wzrostem metrażu, rośnie ilość pokoi ceteris paribus, co jest dość logiczną zależnością. Podobna, nieco słabsza zależność zachodzi pomiędzy ilością pokoi, a ceną oraz ceną, a metrażem.

# 3. Analiza opisowa

Statystki opisowe dla zmiennej cena
```{r}
mean(czyste_mieszkania$price)
    median(czyste_mieszkania$price)
    sd(czyste_mieszkania$price) #standard deviation
    var(czyste_mieszkania$price) #variance
    coeff_var<-sd(czyste_mieszkania$price)/mean(czyste_mieszkania$price) #coefficient of variability %
    coeff_var
    IQR(czyste_mieszkania$price)# difference between quartiles =Q3-Q1 
    sx<-IQR(czyste_mieszkania$price)/2  #interquartile deviation
    coeff_varx<-sx/median(czyste_mieszkania$price) #IQR coefficient of variability %
    coeff_varx
    min(czyste_mieszkania$price)
    max(czyste_mieszkania$price)
    quantile(czyste_mieszkania$price,probs=c(0,0.1,0.25,0.5,0.75,0.95,1),na.rm=TRUE)
```

Statystyki opisowe dla zmiennej cena za metr kwadratowy
```{r}
mean(czyste_mieszkania$pricePerSquareMeter)
median(czyste_mieszkania$pricePerSquareMeter)
sd(czyste_mieszkania$pricePerSquareMeter) #standard deviation
var(czyste_mieszkania$pricePerSquareMeter) #variance
coeff_var<-sd(czyste_mieszkania$pricePerSquareMeter)/mean(czyste_mieszkania$pricePerSquareMeter) #coefficient of variability %
coeff_var
IQR(czyste_mieszkania$pricePerSquareMeter)# difference between quartiles =Q3-Q1 
sx<-IQR(czyste_mieszkania$pricePerSquareMeter)/2  #interquartile deviation
coeff_varx<-sx/median(czyste_mieszkania$pricePerSquareMeter) #IQR coefficient of variability %
coeff_varx
min(czyste_mieszkania$pricePerSquareMeter)
max(czyste_mieszkania$pricePerSquareMeter)
quantile(czyste_mieszkania$pricePerSquareMeter,probs=c(0,0.1,0.25,0.5,0.75,0.95,1),na.rm=TRUE)
```




```{r}

raport_ <-
       list("Min"=  min(czyste_mieszkania$price),
            "Max"=  max(czyste_mieszkania$price),
            "Kwartyl dolny"=  quantile(czyste_mieszkania$price,0.25),
            "Mediana"=  round(median(czyste_mieszkania$price),2),
            "Kwartyl górny"=  quantile(czyste_mieszkania$price,0.75),
            "Średnia"=  round(mean(czyste_mieszkania$price),2),
            "Odch. std."=  round(sd(czyste_mieszkania$price),2),
            "IQR"=  round(IQR(czyste_mieszkania$price),2),
            "Odchylenie ćwiartkowe"=round(IQR(czyste_mieszkania$price)/2,2),
            "Odch. std. w %"=round((sd(czyste_mieszkania$price)/mean(czyste_mieszkania$price)),2),
            "Odch. ćwiartkowe w %"=round((IQR(czyste_mieszkania$price)/median(czyste_mieszkania$price)),2),
            "Skośność"=round(skewness(czyste_mieszkania$price),2),
            "Kurtoza"=round(kurtosis(czyste_mieszkania$price),2)
            )

raport <- as.data.frame(raport_)
raport
#table<-summary_table(czyste_mieszkania, summaries = raport, by = c("city"))

```
Rozkład cen mieszkań na sprzedaż w zależności od piętra

```{r}
library(gtsummary)
mieszkania %>%
  select(price,floor) %>%
  tbl_summary(
    by=floor,
    type = all_continuous() ~ "continuous2",
    statistic = all_continuous() ~ c(
      "{N_nonmiss}","{mean}","{sd}",
      "{median} ({p25}, {p75})",
      "{min}, {max}"),
    missing = "no",
    label = price ~ "Cena") %>%
  modify_header(label ~ "**Zmienna**") %>%
  modify_caption("**Tabela 1. Rozkład cen wg piętra**") %>%
  bold_labels() %>% 
  add_p(pvalue_fun = ~ style_pvalue(.x, digits = 2))
```

Rozkład cen za metr kwadratowy według wielkości mieszkania

```{r}
czyste_mieszkania %>%
  select(pricePerSquareMeter,sizeCategory) %>%
  tbl_summary(
    by=sizeCategory,
    type = all_continuous() ~ "continuous2",
    statistic = all_continuous() ~ c(
      "{N_nonmiss}","{mean}","{sd}",
      "{median} ({p25}, {p75})",
      "{min}, {max}"),
    missing = "no",
    label = pricePerSquareMeter ~ "Cena za metr kwadratowy") %>%
  modify_header(label ~ "**Zmienna**") %>%
  modify_caption("**Tabela 1. Rozkład cen za metr kwadratowy wg wielkości mieszkania**") %>%
  bold_labels() %>% 
  add_p(pvalue_fun = ~ style_pvalue(.x, digits = 2))
```
# 4. Wnioskowanie statystyczne
library(ggstatsplot)

ggpiestats(
  data=czyste_mieszkania,
  x=price,
  y=type
)
```
```{r}
ggwithinstats(
  data=czyste_mieszkania,
  y=pricePerSquareMeter, # musi być ilościowa
  x =sizeCategory #grupująca
) # test t studenta dla par (sparowanych)
```
# g hedges wartość odchylenia

```{r}
czyste_mieszkania %>%
  filter(city %in% c("gdanks", "warszawa", "krakow")) %>%
         ggbetweenstats(
           y=ceny, 
           x=miasto,
           bf.message = FALSE,
           ylab="cena mieszkania",
           xlab="miasto",
           title="Różnica cen wg miast"
           )
```
## Test t-Studenta - porównanie cen mieszkań w Warszawie i Gdańsku
Hipoteza zerowa (H0): Średnie ceny mieszkań w Gdańsku i Warszawie są równe.
Hipoteza alternatywna (HA): Średnie ceny mieszkań w Gdańsku i Warszawie różnią się.

```{r}
warszawa_gdansk <- mieszkania %>% filter(city %in% c("warszawa", "gdansk"))
ggbetweenstats(
  data = warszawa_gdansk,
  x = city,
  y = price,
  title = "Porównanie cen mieszkań między Warszawą a Gdańskiem",
  xlab = "Miasto",
  ylab = "Cena mieszkania",
  type = "parametric" # Test t-Studenta
)
```

Przeprowadzony test t-Studenta dla niezależnych prób wykazał istotną statystycznie różnicę w średnich 
cenach mieszkań między Warszawą a Gdańskiem (t = -16.015, df = 3607.3, p < 2.2e-16). Średnia cena mieszkania 
w Gdańsku wynosiła 889 465,9 zł, natomiast w Warszawie była wyższa i wynosiła 1 057 419,3 zł. Przedział ufności 
dla różnicy średnich wynosił (-188 514,8 zł; -147 391,9 zł), co oznacza, że ceny w Warszawie były średnio o 147-188 tys. zł 
wyższe. Otrzymane wyniki pozwalają odrzucić hipotezę zerową i potwierdzają, że różnica cen mieszkań między tymi miastami nie 
jest przypadkowa, lecz statystycznie istotna.
