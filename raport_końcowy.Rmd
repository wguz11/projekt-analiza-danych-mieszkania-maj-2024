---
title: 'Analiza mieszkań na sprzedaż w Polsce'
subtitle: 'Analiza opisowa'
author: "Kinga Kreft, Wiktoria Guz, Edyta Drząszcz"
date: "`r Sys.Date()`"
output:
  rmdformats::downcute:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    highlight: pygments
---


```{r setup, include=FALSE}
## Global options
knitr::opts_chunk$set(cache = TRUE)
library(naniar)
library(ggplot2)
library(hrbrthemes)
library(plotly)
library(ISLR)
library(finalfit)
library(GGally)
library(tidyverse)
library(dlookr)
library(editrules)
library(VIM)
library(validate)
library(dplyr)
library(summarytools)
library(psych)
mieszkania <- read.csv("apartments_pl_2024_05.csv")
```
Dane zostały wczytane z pliku CSV, który zawiera informacje o mieszkaniach dostępnych na sprzedaż w Polsce w maju 2024 roku.  

# 1. Data wrangling
Data wrangling, znane również jako data munging, to proces przygotowywania danych do analizy poprzez oczyszczanie, transformowanie i strukturalizowanie surowych danych. Celem jest przekształcenie danych w formę, która jest łatwiejsza do analizy, eliminując błędy, usuwając duplikaty, uzupełniając brakujące wartości i konwertując dane do odpowiednich formatów.

## 1.1 Wizualizacja brakujących danych

Na początku identyfikujemy brakujące dane w zestawie, aby upewnić się, że analiza będzie oparta na kompletnych i spójnych danych.
Używamy funkcji vis_miss() do wizualizacji braków oraz missing_pattern() do zrozumienia wzorców brakujących wartości.


```{r}
vis_miss(mieszkania)
```

```{r}
missing_pattern(mieszkania)
```

## 1.2 Reguły walidacji danych
Tworzymy zestaw reguł, które definiują poprawność danych. Reguły te pozwalają wyłapać wartości błędne, np. ujemne ceny lub powierzchnie mieszkań.
Dzięki temu możemy upewnić się, że dane spełniają podstawowe założenia logiczne.

```{r}
reguly <- editset(c(
  "price>0",
  "squareMeters>0",
  "rooms>0",
  "floor>0",
  "floorCount>0"
  ))
```
Kolejno sprawdzamy naruszenie reguł.
Wyniki pokazują, ile rekordów łamie zdefiniowane reguły, co może wskazywać na błędy w danych.
summary(violatedEdits(reguly, mieszkania))

```{r}
summary(violatedEdits(reguly, mieszkania))
bledy <- violatedEdits(reguly, mieszkania)
plot(bledy) # Wizualizacja błędów dla łatwiejszej interpretacji
```
Następnie przeprowadzona została zamiana pustych ciągów lub niepoprawnych wartości na NA
Dane mogły zawierać puste ciągi (" ", "") lub nieprawidłowe wartości, które zostały zamienione na NA, aby łatwiej było je wykluczyć.


```{r}
mieszkania[mieszkania == " "] <- NA

mieszkania[mieszkania == "  "] <- NA

mieszkania[mieszkania == ""] <- NA

mieszkania[localizeErrors(reguly,mieszkania)$adapt] <- NA
```


## 1.3 Imputacja brakujących danych

Uzupełnianie brakujących danych metodą hot-deck, która zastępuje brakujące wartości na podstawie podobnych rekordów.
Jest to efektywna metoda w przypadku, gdy dane mają wiele braków, ale są wystarczająco kompletne do uzupełnienia na podstawie istniejących wzorców.

```{r}
czyste_mieszkania <- hotdeck(mieszkania)

```
Po uzupełnieniu braków sprawdzamy podsumowanie danych, aby upewnić się, że proces przebiegł pomyślnie.

```{r}
summary(czyste_mieszkania)

```
## 1.5 Transformacja danych
Aby dostarczyć dodatkowych informacji wartych przeanalizowania, tworzymy nowe zmienne.
Pomagają one w lepszym zrozumieniu danych i umożliwiają bardziej szczegółowe analizy.
W tym celu tworzymy zmienną "pricePerSquareMeter" określającą cenę za metr kwadratowy. Jest to ważna metryka w analizie rynku nieruchomości, ponieważ pozwala na porównanie cen mieszkań niezależnie od ich wielkości.

```{r}
czyste_mieszkania <- czyste_mieszkania %>% mutate(pricePerSquareMeter = price / squareMeters)
```

View(czyste_mieszkania)
Dodatkowo, warto jet utworzyć kategorię wielkości mieszkań.
W tym celu zastosujemy podział mieszkań na małe, średnie i duże na podstawie powierzchni użytkowej. Kategoryzacja ta ułatwi analizę porównawczą.
```{r}
czyste_mieszkania <- czyste_mieszkania %>% mutate(
  sizeCategory = case_when(
    squareMeters < 40 ~ "Małe", # Mieszkania poniżej 40m2
    squareMeters >= 40 & squareMeters < 80 ~ "Średnie", # Mieszkania od 40m2 do 80m2
    squareMeters >= 80 ~ "Duże" # Mieszkania powyżej 80m2
  )
)
```


```{r}
ggplot(czyste_mieszkania, aes(x=price,fill=condition)) + geom_histogram(binwidth=100000) + labs(title="ceny mieszkań na sprzedaż w Polsce", x="cena", y="ilość") + theme_ipsum()
```


  
ggplot
```{r}
ggplot(czyste_mieszkania, aes(x=price,fill=hasParkingSpace)) + geom_histogram(binwidth=100000) + labs(title="ceny mieszkań na sprzedaż w Polsce", x="cena", y="ilość") + theme_ipsum()

ggplot(czyste_mieszkania, aes(x=price,fill=type)) + geom_histogram(binwidth=100000) + labs(title="ceny mieszkań na sprzedaż w Polsce", x="cena", y="ilość") + theme_ipsum()

ggplot(czyste_mieszkania, aes(x=price,fill=buildingMaterial)) + geom_histogram(binwidth=100000) + labs(title="ceny mieszkań na sprzedaż w Polsce", x="cena", y="ilość") + theme_ipsum()
```


```{r}
ggplot(czyste_mieszkania, aes(x = price, fill = type)) +
geom_density(alpha = 0.5) +
labs(
title = "Rozkład cen mieszkań według standardu lokalu",
x = "Cena" ,
y = "Typ",
fill = "Typ"
) +
theme_minimal()
```


```{r}
ggplot(czyste_mieszkania, aes(x = city, y = price)) +
geom_boxplot(fill = "pink", color = "blue") +
labs(
title = "Cena mieszkań według miasta",
x = "miasto" ,
y = "cena"
) +
theme_minimal()
theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r}
ggcorr(
data = czyste_mieszkania %>% select(where(is.numeric)),
method = c("pairwise.complete.obs" , "pearson"),
label = TRUE
) +
theme(
axis.text.x = element_text(hjust = 1), 
axis.text.y = element_text(hjust = 1)
)
```




```{r}
mean(price)
    median(price)
    sd(price) #standard deviation
    var(price) #variance
    coeff_var<-sd(price)/mean(price) #coefficient of variability %
    coeff_var
    IQR(price)# difference between quartiles =Q3-Q1 
    sx<-IQR(price)/2  #interquartile deviation
    coeff_varx<-sx/median(price) #IQR coefficient of variability %
    coeff_varx
    min(price)
    max(price)
    quantile(price,probs=c(0,0.1,0.25,0.5,0.75,0.95,1),na.rm=TRUE)
```



```{r}
raport <-
  list("price" =
       list("Min"=  min(price),
            "Max"=  max(price),
            "Kwartyl dolny"=  quantile(price,0.25),
            "Mediana"=  round(median(price),2),
            "Kwartyl górny"=  quantile(price,0.75),
            "Średnia"=  round(mean(price),2),
            "Odch. std."=  round(sd(price),2),
            "IQR"=  round(IQR(price),2),
            "Odchylenie ćwiartkowe"=round(IQR(price)/2,2),
            "Odch. std. w %"=round((sd(price)/mean(price)),2),
            "Odch. ćwiartkowe w %"=round((IQR(price)/median(price)),2),
            "Skośność"=round(skew(price),2),
            "Kurtoza"=round(kurtosi(price),2)
            ))
table<-summary_table(czyste_mieszkania, summaries = raport, by = c("city"))

```

```{r}
library(gtsummary)
mieszkania %>%
  select(price,floor) %>%
  tbl_summary(
    by=floor,
    type = all_continuous() ~ "continuous2",
    statistic = all_continuous() ~ c(
      "{N_nonmiss}","{mean}","{sd}",
      "{median} ({p25}, {p75})",
      "{min}, {max}"),
    missing = "no",
    label = price ~ "Cena") %>%
  modify_header(label ~ "**Zmienna**") %>%
  modify_caption("**Tabela 1. Rozkład cen wg piętra**") %>%
  bold_labels() %>% 
  add_p(pvalue_fun = ~ style_pvalue(.x, digits = 2))
```






